---
title: "First-Order Logic Made Friendly: From â€˜Socrates Is Mortalâ€™ to Automatic Proofs"
date: 2023-12-25
permalink: /posts/2023/12/first-order-logic/
tags:
  - artificial intelligence
  - first-order logic
  - unification
  - forward chaining
  - backward chaining
  - resolution
  - beginner
math: true
---

*If youâ€™ve ever said â€œ**Everyone** in the club must pay dues, therefore  
**Alice** must pay,â€ youâ€™ve already used **first-order logic** (FOL).*

This post turns Chapters 8 & 9 into bite-sized steps:

1. **Why We Outgrew Propositional Logic**
2. **Syntax & Semantics of FOL**
3. **Talking in FOL: Examples & Patterns**
4. **Knowledge Engineering Tips**
5. **Inference: How to Prove Stuff in FOL**
    * Unification & Lifting
    * Forward vs Backward Chaining
    * Full First-Order Resolution
6. **Cheat-Sheet & DIY Exercises**

No headachesâ€”just tiny formulas, word-pictures, and micro-code.

---

## 1 Representation Revisited (8Â·1)

Propositional logic says only **whole sentences** are true or false.  
But the world has **objects**, **relations**, **quantities**.

| Need                                 | Propositional? | First-Order? |
|--------------------------------------|----------------|--------------|
| â€œ*Any* cat that purrs is happyâ€      | âŒ              | âœ…ï¸           |
| Nested relations (`Loves(Alice, x)`) | âŒ              | âœ…ï¸           |
| Infinite domains (all integers)      | âŒ              | âœ…ï¸           |

---

## 2 Syntax & Semantics of FOL (8Â·2)

| Piece          | Symbol   | Example       | Reads as                  |
|----------------|----------|---------------|---------------------------|
| **Constant**   | `a`      | `alice`       | a thing                   |
| **Variable**   | `x`      | `x`           | unknown thing             |
| **Predicate**  | `P`      | `Cat(x)`      | property/relationship     |
| **Function**   | `f`      | `MotherOf(x)` | object from object        |
| **Quantifier** | `âˆ€`, `âˆƒ` | `âˆ€x Cat(x)`   | â€œfor allâ€, â€œthere existsâ€ |

Example sentence:

$$
\forall x \, (Cat(x) \rightarrow Loves(x,\;FishOfTheDay)).
$$

> â€œEvery cat loves the fish-of-the-day.â€

**Semantics:** interpret over some **domain**. A sentence is *true* if it holds in **every** world that follows the
interpretation.

---

## 3 Using First-Order Logic (8Â·3)

### 3Â·1 Rules in English â†’ FOL

| English                      | FOL                                                                        |
|------------------------------|----------------------------------------------------------------------------|
| â€œAll surgeons are doctors.â€  | $$ ( \forall x\, (Surgeon(x) \rightarrow Doctor(x)) ) $$                   |
| â€œSome doctor loves Alice.â€   | $$ ( \exists y\, (Doctor(y) \land Loves(y,\,alice)) ) $$                   |
| â€œThere is exactly one king.â€ | $$ ( \exists k\, (King(k) \land \forall x \,(King(x)\rightarrow x=k)) ) $$ |

> **Tip:** write English, mark *every noun phrase* â†’ variable; *is/are* â†’ predicate.

---

## 4 Knowledge Engineering in FOL (8Â·4)

1. **Choose the right ontology** â€“ constants vs functions (use `ParentOf(x)` **or** binary `Parent(x,y)`, not both).
2. **Avoid endless equality chains** â€“ add `UniqueID(x)` facts or use **unique-name assumption** when safe.
3. **Layer your KB** â€“ *facts* âœ *rules* âœ *meta-rules*; keep each layer short and coherent.

> **Debug trick:** query your KB with a SAT/first-order prover after every batch of rulesâ€”catch contradictions early.

---

## 5 Inference in FOL (Ch. 9)

### 5Â·1 Propositional vs First-Order Inference (9Â·1)

Propositional **resolution** works on *ground* sentences.  
FOL lifts it by adding **variables** & **substitution**â€”more power, same taste.

---

### 5Â·2 Unification & Lifting (9Â·2)

**Unify** two atomic sentences by finding a substitution Î¸ that makes them identical.

```python
def unify(x, y, Î¸={}):
    if Î¸ is None: return None
    if x == y:   return Î¸
    if is_var(x): return unify_var(x, y, Î¸)
    if is_var(y): return unify_var(y, x, Î¸)
    if is_compound(x) and is_compound(y):
        return unify(x.args, y.args, unify(x.op, y.op, Î¸))
    return None
```

Example:

```
Knows(John, y)  and  Knows(x, Mother(x))
Î¸ = { x/John , y/Mother(John) }
```

---

### 5Â·3 Forward Chaining (9Â·3)

*Data-driven*: start with facts, repeatedly fire rules that match.

1. Index predicates for O(1) retrieval.
2. Each new inferred fact goes into an **agenda**; loop until agenda empty.

Great for **databases** with many facts but few queries.

---

### 5Â·4 Backward Chaining (9Â·4)

*Goal-driven*: start with query, break into sub-goals.

Prolog = backward chaining + depth-first search + unification.

```prolog
mortal(X) :- human(X).
human(socrates).
?- mortal(socrates).   % succeeds
```

Backtracking explores alternate proofs on failure.

---

### 5Â·5 First-Order Resolution (9Â·5)

1. **Skolemise** (eliminate âˆƒ by functions).
2. Convert to **clausal form** (CNF).
3. Apply **LG (Lifted Ground)-resolution**:  
   Choose clauses **Câ‚**, **Câ‚‚**, find literals **L** & **Â¬L'** that unify via Î¸, derive `Câ‚Î¸ âˆª Câ‚‚Î¸`.

Sound & complete; real solvers add **ordering & subsumption** to prune.

---

## 6 Cheat-Sheet ğŸ§¾

```
FOL syntax    = Constants, variables, predicates, functions, âˆ€, âˆƒ
Semantics     = Interpret over a domain; truth = true in all models
Unification   = Build Î¸ s.t. Î±Î¸ = Î²Î¸
Forward chain = Data-driven rule firing
Backward chain= Goal-driven sub-goal breakdown (Prolog)
Lifting       = Turn propositional resolution into variable form
Skolemization = Remove âˆƒ by new functions/constants
Sound         = Never proves false; Complete = proves all truths
```

---

## 7 Try It Yourself ğŸ§ª

1. **Family Tree KB**  
   Encode `Parent`, `Ancestor`, `Sibling` rules. Prove `Ancestor(alice, bob)` with backward chaining.
2. **Tiny SAT vs FOL**  
   Translate three FOL facts about pets into propositional ground instances; compare clause counts.
3. **Prolog Wumpus**  
   Port your propositional Wumpus agent into Prolog rules with variables (much shorter!).

---

### ğŸš€Final Words

Propositional logic was **chess in 2 Ã— 2 board**.  
First-Order Logic unlocks *all* pieces, letting agents talk about **things**, **groups**, **relations**.

Learn to:

- **Write** crisp FOL sentences,
- **Unify** symbols like puzzle pieces,
- **Chain** rules forward or backward, and
- **Resolve** any dispute to the empty clause.

Then your AI wonâ€™t just *list* factsâ€”it will **reason** about *who, what, where,* and *why*.

**Happy provingâ€”may your substitutions always unify!**