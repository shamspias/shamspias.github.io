---
title: "Logical Agents 101: Slaying the Wumpus with Pure Reason"
date: 2023-12-02
permalink: /posts/2023/12/logical-agents/
tags:
  - artificial intelligence
  - knowledge representation
  - propositional logic
  - theorem proving
  - sat solver
  - wumpus world
  - beginner
math: true
---

*If youâ€™ve ever used clues in a murder-mystery board gameâ€”  
â€œMrs Peacock **and** the Revolver canâ€™t **both** be innocent!â€â€”  
you already reason like a **logical agent***.

This post unwraps Chapter 7 classics in snack-sized pieces:

1. **Knowledge-Based Agents**
2. **The Wumpus World (our cartoon dungeon)**
3. **What Even *Is* Logic?**
4. **Propositional Logic, the Tiny But Mighty**
5. **Theorem Proving by Resolution**
6. **Model Checking & SAT, Super-Fast Proof by Search**
7. **Building a Wumpus-Safe Agent**

No sweeping proofsâ€”just pocket math, word-pictures, and tiny code.

---

## 1 Knowledge-Based Agents (7Â·1)

| Layer                | Purpose                           | Example                 |
|----------------------|-----------------------------------|-------------------------|
| **KB**               | Store *sentences* (facts + rules) | `B13 â†’ P23`             |
| **Inference Engine** | Entail new sentences              | `Â¬P23`                  |
| **Action Rule**      | Map beliefs â†’ actions             | â€œIf gold âˆ§ safe â†’ grabâ€ |

> **Loop:** *Perceive â†’ Tell KB â†’ Ask KB â†’ Act*.

---

## 2 Welcome to the **Wumpus World** (7Â·2)

A 4Ã—4 grid with:

* **Gold** (yay)
* **Wumpus** (fangs)
* **Pits** (fall, game over)

Percepts:

- **Stench** â† Wumpus adjacent
- **Breeze** â† Pit adjacent
- **Glitter** â† Gold here

Goal: grab gold, climb outâ€”alive.

> **Fun fact:** a real Wumpus agent won the early AAAI â€œgold-miningâ€ contest.

---

## 3 Logic in One Sip (7Â·3)

| Concept        | One-liner                                                   |
|----------------|-------------------------------------------------------------|
| **Syntax**     | How you write sentences                                     |
| **Semantics**  | What makes them true/false                                  |
| **Entailment** | KB âŠ¨ Î± means every world where KB is true also makes Î± true |
| **Inference**  | Procedure that derives Î± from KB                            |

A system is **sound** if it never lies, **complete** if it finds every truth.

---

## 4 Propositional Logic: The Tiny Giant (7Â·4)

*Atoms* = symbols `P23`, `B13`, â€¦  
*Connectives* = `Â¬, âˆ§, âˆ¨, â†’`.

Example rule:

$$
B_{13} \;\rightarrow\; P_{23}\lor P_{14}.
$$

Read: *If I feel a breeze in (1,3), then thereâ€™s a pit in (2,3) **or** (1,4).*

---

## 5 Proving Theorems by **Resolution** (7Â·5)

1. Convert everything to **CNF** (clauses).
2. Add `Â¬Î±` (negated query).
3. Repeatedly apply the single rule:

$$
\frac{A\lor X,\;\;Â¬A\lor Y}{X\lor Y}
$$

4. Derive the **empty clause** â‡’ contradiction â‡’ KB âŠ¨ Î±.

> **Why it rocks:** one rule, easy for computers.

### 5Â·1 Mini Code â€“ Resolution in 12 Lines

```python
def resolve(ci, cj):
    resolvents = set()
    for lit in ci:
        if ('Â¬' + lit) in cj or (lit.startswith('Â¬') and lit[1:] in cj):
            resolvents.add(tuple(sorted((ci - {lit}) | (cj - {lit.lstrip('Â¬')}))))
    return resolvents


def pl_resolution(kb, alpha):
    clauses = kb | {tuple('Â¬' + l for l in alpha)}
    new = set()
    while True:
        pairs = [(ci, cj) for i, ci in enumerate(clauses)
                 for cj in list(clauses)[i + 1:]]
        for (ci, cj) in pairs:
            for resolvent in resolve(set(ci), set(cj)):
                if not resolvent:  # derived empty clause
                    return True
                new.add(resolvent)
        if new.issubset(clauses):
            return False
        clauses |= new
```

Works for toy Wumpus deductions.

---

## 6 Effective Model Checking â†’ **SAT** (7Â·6)

Truth-table enumeration is $$ (O(2^n)) $$ .  
Modern trick: hand the CNF to a **SAT solver** â‡’ millions of variables in seconds.

> **DPLL + unit propagation + clause learning** = industrial magic.

### 6Â·1 Snap-In Python SAT

```python
from pysat.solvers import Glucose3

g = Glucose3()
# add CNF clauses as lists of ints, e.g. [1, -2]  (P1 âˆ¨ Â¬P2)
for clause in cnf:
    g.add_clause(clause)
print(g.solve())
```

---

## 7 Agents Based on Propositional Logic (7Â·7)

**Wumpus Agent Algorithm**

1. Start in (1,1), KB â† `Â¬P11 âˆ§ Â¬W11`.
2. Loop:
    * Perceive (`stench`, `breeze`, â€¦) â‡’ add to KB.
    * Ask KB which neighboring squares are **safe** (`Ask(KB, Safe(x,y))`).
    * If safe âˆ§ unvisited â‡’ move there.
    * Else, if glitter â‡’ `Grab`; if at exit â‡’ `Climb`.
    * Else, plan safest route home.

Proved **sound**: never steps into a cell itâ€™s unsure is safe.

---

## 8 Cheat-Sheet ğŸ§¾

```
KB agent  = Perceive â†’ Tell â†’ Ask â†’ Act
Entailment (âŠ¨) = All worlds of KB make Î± true
Resolution    = One-rule refutation proof in CNF
SAT solving   = Model checking via Boolean search
DPLL          = Backtracking SAT with smart pruning
Wumpus agent  = Marks safe cells, moves only where âŠ¨ Safe
Sound         = Never derives false; Complete = finds all truths
```

---

## 9 Try It Yourself ğŸ§ª

1. **Prove Safe Squares**  
   Encode a 2Ã—2 Wumpus world; ask a SAT solver if (1,2) is pit-free after a breeze in (1,1).
2. **CNF Speed Test**  
   Grow random 50-symbol KBs; compare resolution vs PySAT runtime.
3. **Build a Mini Wumpus GUI**  
   Use Pygame; wire your logical agent to move liveâ€”watch it hesitate at breezes!

---

### ğŸš€Final Words

Classical search shows *how* to get somewhere once the world is friendly.  
**Logical agents** thrive when the world is *mysterious* but rule-bound:

- Stuff the facts into a KB,
- Let sound inference spit out certainties,
- And act only on whatâ€™s provably safe.

Master these moves and youâ€™ll not just dodge the Wumpusâ€”youâ€™ll out-reason any labyrinth built of pure logic.

**Happy reasoningâ€”may your clauses always resolve to truth!**