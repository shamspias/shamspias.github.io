---
title: "Classical Planning 101: From STRIPS Blocks to Graphplan Magic"
date: 2024-01-15
permalink: /posts/2024/01/classical-planning/
tags:
  - artificial intelligence
  - planning
  - strips
  - state-space search
  - planning graph
  - hierarchical planning
  - beginner
math: true
---

*If youâ€™ve ever written a to-do listâ€”**â€œget key â†’ unlock door â†’ leave houseâ€**â€”  
youâ€™ve already built a **plan**. Classical planning turns that intuition into algorithms that guarantee the sequence really works.*

This post distills Chapter 10 staples into snack-sized blocks:

1. **What Counts as *Classical* Planning?**  
2. **State-Space Algorithms (Forward, Backward, Heuristics)**  
3. **Planning Graphs & the Graphplan Algorithm**  
4. **Other Approaches (Partial-Order, SAT, Hierarchical)**  
5. **How to Pick the Right Tool**  

No heavy proofsâ€”just tiny STRIPS tables, pocket code, and aha! moments.

---

## 1 Definition of Classical Planning (10Â·1)

Assumptionsâ€”so neat they fit on a postcard:

| Assumption | Means |
|------------|-------|
| **Deterministic** | Each actionâ€™s effects are certain |
| **Fully Observable** | The agent always knows the current state |
| **Static** | World changes **only** when agent acts |
| **Discrete & Finite** | Countable states, actions |
| **Goal = logical formula** | e.g. `At(robot, RoomB) âˆ§ Holding(key)` |

A **problem** is âŸ¨*States*, *Actions*, *Start*, *Goal*âŸ©.  
A **solution** is an **ordered list of actions** turning *Start* into any *Goal* state.

---

### 1Â·1 STRIPS Action Schema

| Field   | Example (`Pickup(x)`) |
|---------|-----------------------|
| **Preconditions** | `HandEmpty âˆ§ OnTable(x)` |
| **Add list**      | `Holding(x)` |
| **Delete list**   | `HandEmpty, OnTable(x)` |

Think *subtract + add* patches to the worldâ€™s fact set.

---

## 2 Algorithms for Planning as **State-Space Search** (10Â·2)

### 2Â·1 Forward vs Backward

| Direction | Node = | Branching | Pros |
|-----------|--------|-----------|------|
| **Forward (Progression)** | current state | #actions true now | Easy preconditions |
| **Backward (Regression)** | goal-subgoal | #actions that could achieve subgoal | Ignores irrelevant facts |

### 2Â·2 Heuristics for Planning

A popular trick: **delete-relaxation**â€”pretend actions never delete facts â‡’ the relaxed problem is easy and its solution length `hâº` is **admissible**.

```python
from planning import reachable, actions      # tiny helper stubs
def h_delete_relax(state, goal):
    layer, world = 0, {state}
    while not any(g âŠ† s for s in world):
        layer += 1
        new_states = { s | a.add for s in world for a in actions if a.pre âŠ† s }
        if not new_states: return float("inf")
        world |= new_states
    return layer
```

Combine with **A*** or **Greedy Best-First** for fast solutions on Blocks World.

---

## 3 **Planning Graphs** (10Â·3)

Graphplan builds a leveled graph:

1. **State levels** $$ ( S_0, S_1, â€¦ ) $$ â€“ facts that *could* hold.  
2. **Action levels** $$ ( A_0, A_1, â€¦ ) $$ â€“ actions whose pre-conditions appear in $$ ( S_k ) $$.  
3. **Mutex links** â€“ facts/actions that cannot co-occur.

Algorithm:

1. Expand levels until **all goal literals** appear **non-mutex**.  
2. **Backward search** through the graph chooses consistent actions â†’ yields a plan.  
3. If search fails, add another level and repeat.

> **Magic:** Graphplanâ€™s mutual-exclusion pruning often slashes the search space by orders of magnitude.

---

## 4 Other Classical Planning Approaches (10Â·4)

| Family | Core Idea | Famous Systems |
|--------|-----------|----------------|
| **Partial-Order (POP)** | Leave steps unordered unless needed â†’ flexible plan | UCPOP |
| **Planning-as-SAT** | Encode time-stamped actions as Boolean vars â†’ hand to SAT solver | Blackbox |
| **CSP Encoding** | Similar to SAT but multi-valued vars | Optiplan |
| **Hierarchical Task Networks (HTN)** | Decompose abstract tasks into subtasks | SHOP2 |

> **Rule of thumb:**  
> *Deep recipe with reusable steps?* â†’ **POP/HTN**.  
> *Shallow but huge branching?* â†’ **SAT**.

---

## 5 Analysis & Trade-Offs (10Â·5)

| Criterion          | State-Search | Graphplan | SAT/CSP | HTN |
|--------------------|-------------|-----------|---------|-----|
| **Plan optimality?** | Yes (with A\*) | Yes | Yes/No (depends) | Designer-guided |
| **Memory use**     | Low          | Medium    | High (CNF grows) | Variable |
| **Domain modeling**| Simple STRIPS | STRIPS | Boolean encode   | Rich (methods) |
| **Scales to 1000s actions?** | Needs good heuristic | Often | Yes (SAT solvers love big) | Yes |

---

## 6 Cheat-Sheet ðŸ§¾

```
Classic planning = deterministic, fully observable, finite
STRIPS           = Pre, Add, Delete lists
Progression      = search forward through states
Regression       = search backward from goal
Delete-relax h+  = ignore deletes to get admissible length
Planning graph   = levels of facts/actions + mutex; Graphplan extracts plan
POP              = only order what must be ordered
SAT planning     = encode as Boolean CNF, solve with modern SAT
HTN              = top-down task decomposition
```

---

## 7 Try It Yourself ðŸ§ª

1. **Blocks World Race**  
   Implement delete-relax heuristic; compare A\* vs plain BFS on 4-block towers.
2. **Graphplan Visualizer**  
   Build a tiny script that prints each levelâ€™s mutex pairsâ€”watch conflicts vanish as levels grow.
3. **SAT Logistics**  
   Encode a 2-city delivery problem (Trucks + Planes) into CNF; feed into a SAT solver; decode model into an action list.

---

### ðŸš€Final Words

Classical planning is the art of **turning goals into guaranteed recipes**â€”no surprises, no dice rolls.

*Forward search* plows ahead, *regression* works backward, *Graphplan* meets in the middle, and SAT planners brute-force with modern Boolean muscle. Choose the flavor that matches your puzzle pieces, sprinkle in a smart heuristic, and the plan practically writes itself.

**Happy planningâ€”may your delete lists never bite and your goals appear mutex-free!**